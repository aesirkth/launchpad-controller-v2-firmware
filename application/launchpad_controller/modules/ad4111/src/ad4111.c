/*
 * AD4111 Analog to Digital Converter (ADC) Driver
 *
 * Author: Love Mitteregger
 * Created: 10 jun 2024
 *
 */

// Find Zephyr Device Tree Bindings
// #define DT_DRV_COMPAT analog_ad4111

// General libraries
#include <math.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

// Zephyr libraries
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/device.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/devicetree.h>
#include <zephyr/linker/devicetree_regions.h>
// #include <zephyr/ztest.h> // Zephyrs Testing Framework, must also be enabled in prj.conf if used

// AESIR libraries
#include "ad4111.h"
#include "no_os/ad411x_regs.h"

// Placeholder

// Set logging system to capture any log messages generated by the code
LOG_MODULE_REGISTER(ad4111, CONFIG_SENSOR_LOG_LEVEL);

/* REMEMBER: DRIVER FUNCTIONS SHOULD BE DESIGNED TO OPERATE INDEPENDENTLY OF THE NUMBER OF DEVICES USING THEM. */

/* Data struct used to hold instance-specific data that may change at runtime.
 * Each instance of the AD4111 driver will have its own ad4111_data structure,
 * allowing independent operation of multiple instances. */
struct ad4111_config {
    struct spi_dt_spec spi; // This structure holds the SPI configuration for the AD4111 instance. It includes details like the SPI bus, chip select, and maximum frequency. The SPI_DT_SPEC_INST_GET(inst) macro in the AD4111_DEVICE_DEFINE macro fills this structure based on device tree settings.
    struct gpio_dt_spec cs_gpio;
    uint32_t spi_max_frequency;
    uint8_t channels;
    ad717x_dev ad717x;
};

struct ad4111_data {
};

/* Function for resetting the AD4111 ADC
 * After a power-up cycle and when the power supplies are stable, a device reset is required.
 * Furthermore, in situations where interface synchronization is lost, a device reset is also required.
 * Returning CS high sets the digital interface to the default state and halts any serial interface operation. */
static int ad4111_driver_reset(const struct device *dev) {
    const struct ad4111_config *config = dev->config;

    gpio_pin_set_dt(&config->cs_gpio, 0); // Toggle CS-complement high for reset
    k_sleep(K_MSEC(1)); // wait a bit
    gpio_pin_set_dt(&config->cs_gpio, 1); // Toggle CS-complement low to allow data flow
    k_sleep(K_MSEC(1)); // wait a bit

    return 0;
};

static int ad4111_driver_init(const struct device *dev) {
    const struct ad4111_config *config = dev->config;
    const int channel_count = 12;
    struct ad717x_channel_map chan_map[12];

    for (int i = 0; i < 12; i++) {
        chan_map[i].channel_enable = 1;
    }

    chan_map[0].analog_inputs.analog_input_pairs = VIN0_VINCOM;
    chan_map[0].setup_sel = 0;
    chan_map[1].analog_inputs.analog_input_pairs = VIN1_VINCOM;
    chan_map[1].setup_sel = 0;
    chan_map[2].analog_inputs.analog_input_pairs = VIN2_VINCOM;
    chan_map[2].setup_sel = 0;
    chan_map[3].analog_inputs.analog_input_pairs = VIN3_VINCOM;
    chan_map[3].setup_sel = 0;
    chan_map[4].analog_inputs.analog_input_pairs = VIN4_VINCOM;
    chan_map[4].setup_sel = 0;
    chan_map[5].analog_inputs.analog_input_pairs = VIN5_VINCOM;
    chan_map[5].setup_sel = 0;
    chan_map[6].analog_inputs.analog_input_pairs = VIN6_VINCOM;
    chan_map[6].setup_sel = 0;
    chan_map[7].analog_inputs.analog_input_pairs = VIN7_VINCOM;
    chan_map[7].setup_sel = 0;

    chan_map[8].analog_inputs.analog_input_pairs = IIN0P_IIN0M;
    chan_map[7].setup_sel = 1;
    chan_map[9].analog_inputs.analog_input_pairs = IIN1P_IIN1M;
    chan_map[7].setup_sel = 1;
    chan_map[10].analog_inputs.analog_input_pairs = IIN2P_IIN2M;
    chan_map[7].setup_sel = 1;
    chan_map[11].analog_inputs.analog_input_pairs = IIN3P_IIN3M;
    chan_map[7].setup_sel = 1;

    struct ad717x_channel_setup chan_setup[2];
    chan_setup[0].bi_unipolar = false; // unipolar
    chan_setup[0].input_buff = true;
    chan_setup[0].ref_buff = false;

    chan_setup[1].bi_unipolar = false; // unipolar
    chan_setup[1].input_buff = false;
    chan_setup[1].ref_buff = false;

    uint32_t pga[2] = {0};

    struct ad717x_filtcon filter_conf[2];
    filter_conf[0].enhfilten = false;
    filter_conf[0].oder = sinc5_sinc1; // single cycle
    filter_conf[0].odr = sps_2957;

    filter_conf[1].enhfilten = false;
    filter_conf[1].oder = sinc5_sinc1; // single cycle
    filter_conf[1].odr = sps_2957;

    ad717x_init_param param = {
        .spi_init = NULL,
        .regs = ad4111_regs,
        .num_regs = 55, // I mean idk
        .active_device = ID_AD4111,
        .ref_en = true,
        .num_channels = 12,
        .num_setups = 2,
        .setups = chan_setup,
        .chan_map = chan_map,
        .pga = pga,
        .filter_configuration = filter_conf,
        .mode = CONTINUOUS
    };

    AD717X_Init(&config->ad717x, param);

    ad4111_driver_reset(dev);

    return 0;
};

// Struct utilizing the adc subsystem api
static struct ad4111_api ad4111_api = {
    .read_volt = NULL, //ad4111_read_register,   // Read from ADC register
    .read_current = NULL, //ad4111_read_data,           // Read from ADC data register NOTE: CONSIDER CHANGING NAME FOR THIS
};

// A macro defining the SPI configuration for AD4111 -- CURRENTLY NOT USED, SEE adc_ads7052.c GitHub FOR REF.
#define AD4111_SPI_CONFIG \
	SPI_OP_MODE_MASTER | SPI_MODE_CPOL | SPI_MODE_CPHA | SPI_WORD_SET(8) | SPI_TRANSFER_MSB
#define AD4111_SPI_CS_HOLD_DELAY 2 //us

// A macro to easily define and initialize an instance of the ADC driver.
#define AD4111_DEVICE_DEFINE(inst)                                      \
    static struct ad4111_data ad4111_data_##inst = {};                  \
                                                                        \
    /* Pull instance configuration from DeviceTree */                   \
    static const struct ad4111_config ad4111_config_##inst = {          \
        .spi = SPI_DT_SPEC_INST_GET(                                    \
            inst,                                                       \
            SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8),    \
            AD4111_SPI_CS_HOLD_DELAY                                    \
        ),                                                              \
        .cs_gpio = SPI_CS_GPIOS_DT_SPEC_INST_GET(inst),                 \
        .spi_max_frequency = DT_INST_PROP(inst, spi_max_frequency),     \
    };                                                                  \
                                                                        \
    DEVICE_DT_INST_DEFINE(                                              \
        inst,                                                           \
        ad4111_driver_init,                                             \
        NULL,                                                           \
        &ad4111_data_##inst,                                            \
        &ad4111_config_##inst,                                          \
        POST_KERNEL,                                                    \
        CONFIG_APPLICATION_INIT_PRIORITY,                               \
        &ad4111_api                                                     \
    );


// Would like to add CONFIG_ADC_INIT_PRIORITY instead of '90' in the
// Macro definition above...

// Instantiate all defined instances
DT_INST_FOREACH_STATUS_OKAY(AD4111_DEVICE_DEFINE);