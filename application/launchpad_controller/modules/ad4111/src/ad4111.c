/*
 * AD4111 Analog to Digital Converter (ADC) Driver
 *
 * Author: Love Mitteregger
 * Created: 10 jun 2024
 *
 */
#define DT_DRV_COMPAT analog_ad4111

// Find Zephyr Device Tree Bindings

// General libraries
#include <math.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

// Zephyr libraries
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/device.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/devicetree.h>
#include <zephyr/linker/devicetree_regions.h>
// #include <zephyr/ztest.h> // Zephyrs Testing Framework, must also be enabled in prj.conf if used

// AESIR libraries
#include "../inc/ad4111.h"
#include "ad4111_driver.h"
#include "no_os/ad411x_regs.h"


// Set logging system to capture any log messages generated by the code
LOG_MODULE_REGISTER(ad4111, CONFIG_SENSOR_LOG_LEVEL);


static int ad4111_driver_init(const struct device *dev) {
    struct ad4111_data *data = dev->data;
    const int channel_count = 12;
    struct ad717x_channel_map chan_map[channel_count];

    for (int i = 0; i < channel_count; i++) {
        chan_map[i].channel_enable = 1;
    }

    chan_map[0].analog_inputs.analog_input_pairs = VIN0_VINCOM;
    chan_map[0].setup_sel = 0;
    chan_map[1].analog_inputs.analog_input_pairs = VIN1_VINCOM;
    chan_map[1].setup_sel = 0;
    chan_map[2].analog_inputs.analog_input_pairs = VIN2_VINCOM;
    chan_map[2].setup_sel = 0;
    chan_map[3].analog_inputs.analog_input_pairs = VIN3_VINCOM;
    chan_map[3].setup_sel = 0;
    chan_map[4].analog_inputs.analog_input_pairs = VIN4_VINCOM;
    chan_map[4].setup_sel = 0;
    chan_map[5].analog_inputs.analog_input_pairs = VIN5_VINCOM;
    chan_map[5].setup_sel = 0;
    chan_map[6].analog_inputs.analog_input_pairs = VIN6_VINCOM;
    chan_map[6].setup_sel = 0;
    chan_map[7].analog_inputs.analog_input_pairs = VIN7_VINCOM;
    chan_map[7].setup_sel = 0;

    chan_map[8].analog_inputs.analog_input_pairs = IIN0P_IIN0M;
    chan_map[8].setup_sel = 1;
    chan_map[9].analog_inputs.analog_input_pairs = IIN1P_IIN1M;
    chan_map[9].setup_sel = 1;
    chan_map[10].analog_inputs.analog_input_pairs = IIN2P_IIN2M;
    chan_map[10].setup_sel = 1;
    chan_map[11].analog_inputs.analog_input_pairs = IIN3P_IIN3M;
    chan_map[11].setup_sel = 1;

    struct ad717x_channel_setup chan_setup[2];
    chan_setup[0].bi_unipolar = false; // unipolar
    chan_setup[0].input_buff = true;
    chan_setup[0].ref_buff = false;

    chan_setup[1].bi_unipolar = false; // unipolar
    chan_setup[1].input_buff = false;
    chan_setup[1].ref_buff = false;

    uint32_t pga[2] = {0};

    struct ad717x_filtcon filter_conf[2];
    filter_conf[0].enhfilten = false;
    filter_conf[0].oder = sinc5_sinc1; // single cycle
    filter_conf[0].odr = sps_2957;

    filter_conf[1].enhfilten = false;
    filter_conf[1].oder = sinc5_sinc1; // single cycle
    filter_conf[1].odr = sps_2957;

    struct no_os_spi_init_param spi;
    spi.extra = (void *) dev; // silence const warning

    ad717x_init_param param = {
        .spi_init = spi,
        .regs = ad4111_regs,
        .num_regs = 55, // I mean idk
        .active_device = ID_AD4111,
        .ref_en = true,
        .num_channels = channel_count,
        .num_setups = 2,
        .setups = {},
        .chan_map = {},
        .pga = {},
        .filter_configuration = {},
        .mode = CONTINUOUS
    };
    memcpy(&param.setups, &chan_setup, sizeof(chan_setup));
    memcpy(&param.chan_map, &chan_map, sizeof(chan_map));
    memcpy(&param.pga, &pga, sizeof(pga));
    memcpy(&param.filter_configuration, &filter_conf, sizeof(filter_conf));

    int e = AD717X_Init(&data->ad717x, param);
    if (e) {
        LOG_ERR("AD717x_init failed with code %d", e);
    } else {
        // LOG_INF("AD717x initialized");
    }
    return e;
};

int ad4111_driver_read_channel(const struct device *dev, int channel, int32_t *value) {
    struct ad4111_data *data = dev->data;

    int e = ad717x_single_read(&data->ad717x, channel, value);
    if (e) {
        LOG_ERR("AD717x_single_read failed with code %d on channel %d", e, channel);
    } else {
        // LOG_INF("AD717x read single value on channel %d", channel);
    }
    return e;
}

// Struct utilizing the adc subsystem api
static struct ad4111_api ad4111_driver_api = {
    .read_channel = ad4111_driver_read_channel, //ad4111_read_register,   // Read from ADC register
};

// A macro defining the SPI configuration for AD4111 -- CURRENTLY NOT USED, SEE adc_ads7052.c GitHub FOR REF.
#define AD4111_SPI_CONFIG \
	SPI_OP_MODE_MASTER | SPI_MODE_CPOL | SPI_MODE_CPHA | SPI_WORD_SET(8) | SPI_TRANSFER_MSB
#define AD4111_SPI_CS_HOLD_DELAY 2 //us

// A macro to easily define and initialize an instance of the ADC driver.
#define AD4111_DEVICE_DEFINE(inst)                                      \
    static struct ad4111_data ad4111_data_##inst = {};                  \
                                                                        \
    /* Pull instance configuration from DeviceTree */                   \
    static const struct ad4111_config ad4111_config_##inst = {          \
        .spi = SPI_DT_SPEC_INST_GET(                                    \
            inst,                                                       \
            SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8),    \
            AD4111_SPI_CS_HOLD_DELAY                                    \
        ),                                                              \
        .cs_gpio = SPI_CS_GPIOS_DT_SPEC_INST_GET(inst),                 \
        .spi_max_frequency = DT_INST_PROP(inst, spi_max_frequency),     \
    };                                                                  \
                                                                        \
    DEVICE_DT_INST_DEFINE(                                              \
        inst,                                                           \
        ad4111_driver_init,                                             \
        NULL,                                                           \
        &ad4111_data_##inst,                                            \
        &ad4111_config_##inst,                                          \
        POST_KERNEL,                                                    \
        CONFIG_APPLICATION_INIT_PRIORITY,                               \
        &ad4111_driver_api                                              \
    );


// Instantiate all defined instances
DT_INST_FOREACH_STATUS_OKAY(AD4111_DEVICE_DEFINE);