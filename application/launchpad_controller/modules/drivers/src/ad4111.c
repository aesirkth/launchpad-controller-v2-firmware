/*
 * AD4111 Analog to Digital Converter (ADC) Driver
 *
 * Author: Love Mitteregger
 * Created: 10 jun 2024
 *
 */

// General libraries
#include <math.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

// Zephyr libraries
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/linker/devicetree_regions.h>
// #include <zephyr/ztest.h> // Zephyrs Testing Framework, must also be enabled in prj.conf if used

// AESIR libraries
#include "ad4111.h"
// Placeholder

// Set logging system to capture any log messages generated by the code
LOG_MODULE_REGISTER(ad4111, CONFIG_SENSOR_LOG_LEVEL);

// Define device tree nodes
#define CS_FLAGS (GPIO_OUTPUT | GPIO_ACTIVE_LOW)
#define ADC1 DT_NODELABEL(ext_adc1)
#define ADC2 DT_NODELABEL(ext_adc2)


// Define ADC threads
/* ------ THREADS PARAMETERS START ------ */
//#define ADC1_THREAD_PRIORITY 7
//#define ADC1_THREAD_STACK_SIZE 2048

//#define ADC2_THREAD_PRIORITY 7
//#define ADC2_THREAD_STACK_SIZE 2048
/* ------- THREADS PARAMETERS END ------- */

/* ------ THREADS INITIALIZATION START ------ */
//#if DT_ALIAS_EXISTS(ext_adc1)
//K_THREAD_STACK_DEFINE(adc1_thread_stack, ADC1_THREAD_STACK_SIZE);
//struct k_thread adc1_thread_data;
//k_tid_t adc1_thread_id;
//void adc1_thread()
//#endif

//#if DT_ALIAS_EXISTS(ext_adc2)
//K_THREAD_STACK_DEFINE(adc2_thread_stack, ADC2_THREAD_STACK_SIZE);
//struct k_thread adc2_thread_data;
//k_tid_t adc2_thread_id;
//void adc2_thread()
//#endif
/* ------- THREADS INITIALIZATION END ------- */

// Get address for SPI Chip Select
// FIX THIS ????
#if DT_NODE_HAS_STATUS(ADC1_NODE, okay)
static const struct gpio_dt_spec adc1_cs = GPIO_DT_SPEC_GET(ADC1_NODE, cs_gpios);
#else
#error "ADC1 node not available or incorrect in device tree"
#endif

#if DT_NODE_HAS_STATUS(ADC2_NODE, okay)
static const struct gpio_dt_spec adc2_cs = GPIO_DT_SPEC_GET(ADC2_NODE, cs_gpios);
#else
#error "ADC2 node not available or incorrect in device tree"
#endif

/*
static const struct gpio_dt_spec adc1_cs = GPIO_DT_SPEC_GET(ADC1, cs_gpios);
static const struct gpio_dt_spec adc2_cs = GPIO_DT_SPEC_GET(ADC2, cs_gpios);

// Function for resetting the ADCs
// Returning CS' high sets the digital interface to the default state and halts any serial interface operation.
static int reset_adc(const struct gpio_dt_spec *cs_addr) {
    
    // Configurate GPIO pin based on address noted in device tree
    int ret = gpio_pin_configure_dt(cs_addr, CS_FLAGS); // Double check CS_FLAGS in this line
    if (ret) {
        LOG_ERR("Error: Failed to configure GPIO for CS, code: %d", ret);
        return ret;
    }

    // Set CS high to reset ADC
    ret = gpio_pin_set_dt(cs_addr, 1);
    if (ret) {
        LOG_ERR("Error: Failed to set CS high, code: %d", ret);
        return ret;
    }

    // Small delay to ensure cs is registered
    k_busy_wait(10);

    // Set CS low
    ret = gpio_pin_set_dt(cs_addr, 0);
    if (ret) {
        LOG_ERR("Error, Failed to set CS low, code: %d", ret);
        return ret;        
    }

    return ret;
}


// Initialize the ADCs
void init_adc(){
    const struct device *adc1 = DEVICE_DT_GET(ADC1);
    const struct device *adc2 = DEVICE_DT_GET(ADC2);

    // Check if devices are ready
    if (!device_is_ready(adc1)) {
        LOG_ERR("Error: ADC1 is not ready, code: %d", ret);
        return;
    }

    if (!device_is_ready(adc2)) {
        LOG_ERR("Error: ADC2 is not ready, code: %d", ret);
        return;
    }

    // If the devices are ready, proceed with resetting both ADCs
    if (reset_adc(&adc1_cs)) {
        LOG_ERR("Error: Failed to reset ADC1, code: %d", ret);
        return;        
    }
    k_sleep(K_MSEC(10));    // Wait for reset of ADC1 to complete
    
    
    if (reset_adc(&adc2_cs)) {
        LOG_ERR("Error: Failed to reset ADC2, code: %d", ret);
        return;
    }
    k_sleep(K_MSEC(10));    // Wait for reset of ADC2 to complete
}
*/